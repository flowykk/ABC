# ИДЗ №4

__Работу выполнил__: Рахманов Данила Дмитриевич

__Вариант__: 29

__Условие задачи__: Преподаватель проводит экзамен у группы студентов. Каждый студент получает свой билет, сообщает его номер и готовит письменный ответ за некоторое случайное время. Подготовив ответ, он передает его преподавателю. Преподаватель некоторое случайное время просматривает ответ и сообщает студенту оценку. Требуется создать многопоточное приложение, моделирующее действия преподавателя и студентов. При решении использовать парадигму «клиент–сервер».

## Что сделано в ИДЗ №4?

### В отчёте присутствуют:
- ссылки на разделы
  
### Оценка 4-5:

### Оценка 6-7:

### Оценка 8:

### Оценка 9:

### Оценка 10:

## Описание кода программы:
Для начала рассмотрим реализацию входных данных в программе. Сначала пользовтелю выводится текст с вариантами ответов и дальнейшими действиями. Из-за цикла `while` пока пользователь не введёт корректный ответ, ввод входных данных не будет завршён:
```cpp
int decision;
std::cout << "Выберите, как Вы хотите ввести данные, нужные для работы программы: \n"
             "1. Взять данные из подготовленного файла. \n"
             "2. Ввести данные в консоль. \n"
             "0. Выйти из программы. \n"
             "В качестве ответа введите одну цифру: 0, 1 или 2: ";
std::cin >> decision;
while (decision != 0 and decision != 1 and decision != 2) {
    std::cout << "Вы должны ввести только цифры 0, 1 или 2! Попробуйте ещё раз: ";
    std::cin >> decision;
}
```

После того, как ответ пользователя оказался корректным, при помощи условий `if` входные данные для программы вводятся либо через файл при помощи `ifstream`, либо через консоль. 

В файле должны находиться данные о количестве студентов и полный путь к выходному файлу, куда будут записаны результаты работы программы. 

В основной части программы присутствует цикл, который создаёт нужное количество потоков студентов:
```cpp
for (int i = 0; i < num_students; ++i) {
    int *student_id = new int(i + 1);
    pthread_create(&students[i], nullptr, StudentThread, (void *)student_id);
}
```

После создаётся поток преподавателя:
```cpp
pthread_create(&teacher, nullptr, TeacherThread, nullptr);
```

В функции `void *StudentThread(void *arg)` входным аргументов является id текущего студента. Внутри цикла `while` сначала происходит блокировка **mutex** при помощи строки `pthread_mutex_lock(&mutex)`, чтобы заблокировать доступ к общим переменным у других потоков студентов. Сначала идёт проверка на то, отвечал ли уже текущий студент на экзамене Далее выводится информация о билете, который выпал студенту, после чего генерируется число **preparation_time** - время подготовки студента к билету. После защиты билета студентом при помощи `pthread_cond_signal(&teacher_cond)` вызывается поток Преподавателя. Когда преподаватель проерил работу, очередь сдачи экзамена переходит к следующему студенту. 
```cpp
void *StudentThread(void *arg) {
    int student_id = *((int *)arg);

    while (true) {
        pthread_mutex_lock(&mutex);

        // Проверка, ответил ли уже этот студент
        if (answered_students >= num_students) {
            pthread_mutex_unlock(&mutex);
            break;
        }

        // Студент выбирает билет
        int ticket = ++current_ticket;
//        sleep(1);
        std::cout << "Студент " << student_id << " выбрал билет: " << ticket << std::endl;
        outputFile << "Студент " << student_id << " выбрал билет: " << ticket << std::endl;

        // Готовится к ответу
        int preparation_time = rand() % 5 + 1; // Генерация случайного времени подготовки (от 1 до 5 секунд)
        std::cout << "Студент " << student_id << " готовится к ответу..." << std::endl;
        outputFile << "Студент " << student_id << " готовится к ответу..." << std::endl;
        pthread_mutex_unlock(&mutex);
        sleep(preparation_time);

        // Защита билета
        pthread_mutex_lock(&mutex);
        std::cout << "Студент " << student_id << " защищает билет: " << ticket << std::endl;
        outputFile << "Студент " << student_id << " защищает билет: " << ticket << std::endl;
        is_teacher_active = true; // Устанавливаем флаг, что преподаватель может действовать
        current_student = student_id;
        answered_students++;
        pthread_cond_signal(&teacher_cond); // Сигнал преподавателю

        std::cout << "студент ждет вердикт" << std::endl;
        outputFile << "студент ждет вердикт" << std::endl;

        // Ожидание оценки
        pthread_cond_wait(&student_cond, &mutex);
        pthread_mutex_unlock(&mutex);
        break; // Завершение потока после ответа
    }

    return nullptr;
}
```

Теперь рассмотрим функцию `void *TeacherThread(void *arg)`. Для начала в цикле блокируется **mutex**, после чего идёт проверка на то, не должен ли закончиться экзамен. Когда преподаватель получает сигнал от студента, генерируется рандомная оценка от 1 до 10, после чего информация об оценке текущего студента выводится на экран. 
```cpp
void *TeacherThread(void *arg) {
    while (true) {
        pthread_mutex_lock(&mutex);

        // Проверка, ответили ли уже все студенты
        if (answered_students >= num_students) {
            std::cout << "Все студенты сдали экзамен. Программа завершена. Результат записан в выходной файл.";
            outputFile << "Все студенты сдали экзамен. ";
            pthread_mutex_unlock(&mutex);
            break;
        }

        // Ожидание сигнала от студента
        while (!is_teacher_active) {
            pthread_cond_wait(&teacher_cond, &mutex);
        }

        // Преподаватель оценивает билет
        int grade = rand() % 10 + 1; // Генерация случайной оценки (от 1 до 10)
        std::cout << "Преподаватель выставляет оценку " << grade << " студенту " << current_student << std::endl;
        outputFile << "Преподаватель выставляет оценку " << grade << " студенту " << current_student << std::endl;

        is_teacher_active = false; // Сбрасываем флаг
        pthread_cond_signal(&student_cond); // Сигнал студенту
        pthread_mutex_unlock(&mutex);
    }

    return nullptr;
}
```
  
## Код программы
### [Главный файл программы](main.asm)

## Логи выполнения программ

