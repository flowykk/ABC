# ИДЗ №4

__Работу выполнил__: Рахманов Данила Дмитриевич

__Вариант__: 29

__Условие задачи__: Преподаватель проводит экзамен у группы студентов. Каждый студент получает свой билет, сообщает его номер и готовит письменный ответ за некоторое случайное время. Подготовив ответ, он передает его преподавателю. Преподаватель некоторое случайное время просматривает ответ и сообщает студенту оценку. Требуется создать многопоточное приложение, моделирующее действия преподавателя и студентов. При решении использовать парадигму «клиент–сервер».

## Что сделано в ИДЗ №4?

### В отчёте присутствуют:
- ссылки на разделы
  
### Оценка 4-5:

### Оценка 6-7:

### Оценка 8:

### Оценка 9:

### Оценка 10:

## Код программы
Полный код программы со всеми комментариями и пояснениями можно посмотреть в [файле](main.cpp)

## Описание общего сценария работы программы
После того, как программа получила от пользователя количество студентов в группе `num_students` и путь в файлу `output_fileName`, куда будет записан результат работы программы, создаётся `num_students` потоков студентов и 1 поток преподавателя. 

### Сценарий работы каждого потока студента
Сначала каждый из студентов выбирает билет, после чего очередь выбора билета переходит к следующему студенту. Время на очередь выбора билетов между студентами генерируется рандомно в диапазоне от 1 до 2 секунд. Время для подготовки представляет собой рандомно сгенерированное время от 1 до 3 секунд. 

Когда время для подготовки заканчивается, студент сдаёт билет преподавателю, после чего работа переходит к потоку преподавателя.

Пока преподаватель проверяет билет (подробнее об этом чуть дальше), студент ждёт вердикт преподавателя. Когда оценка для текущего студента выставлена, очередь защищать билет переходит к следующему студенту.

### Сценарий работы потока преподавателя
Поток преподавателя сначала проверяет, сколько студентов уже ответили свои билеты: если количество студентов, ответивших билеты, равно общему числу студентов, то все студенты уже сдали экзамен, а экзамен вместе с программой завершается.

Когда поток преподавателя получает сигнал от потока текущего студента, преподаватель начинает проверку письменного ответа студента. Время на проверку - генерируемое количество секунду в диапазоне от 1 до 2. Когда билет проверен, генерируется случайная оценка студента за экзамен от 1 до 10, и она выводится на экран. После этого поток преподавателя приостанавливает свою работу, ожидая завершение написания ответа следующего студента.

## Описание генерируемых чисел
- `ticket_number` - Номер билета студента - целое число от 1 до 30.
- `queue_time` - Время очереди после того, как один из студентов выбрал билет - время от 1 до 2 секунд.
- `preparation_time` - Время на подготовку письменного ответа на билет - время от 1 до 3 секунд.
- `checking_time` - Время на проверку билета преподавателем - время от 1 до 2 секунд.
- `grade` - Оценка студента - целое число от 1 до 10. 

## Описание кода программы
### Описание входных данных
Для начала рассмотрим реализацию входных данных в программе. Сначала пользовтелю выводится текст с вариантами ответов и дальнейшими действиями. Из-за цикла `while` пока пользователь не введёт корректный ответ, ввод входных данных не будет завршён:
```cpp
int decision;
std::cout << "Выберите, как Вы хотите ввести данные, нужные для работы программы: \n"
             "1. Взять данные из подготовленного файла. \n"
             "2. Ввести данные в консоль. \n"
             "0. Выйти из программы. \n"
             "В качестве ответа введите одну цифру: 0, 1 или 2: ";
std::cin >> decision;
while (decision != 0 and decision != 1 and decision != 2) {
    std::cout << "Вы должны ввести только цифры 0, 1 или 2! Попробуйте ещё раз: ";
    std::cin >> decision;
}
```

После того, как ответ пользователя оказался корректным, при помощи условий `if` входные данные для программы вводятся либо через файл при помощи `ifstream`, либо через консоль. 

В файле должны находиться данные о количестве студентов и полный путь к выходному файлу, куда будут записаны результаты работы программы. Предусмотрен случай неккоректного пути к файлу, в таком случае в консоли появляется сообщение об ошибке, а программа завершается. Ввод данных через файл происходит следующим способом:
```cpp
std::string inputFileName;
std::cout << "Введите полный путь к файлу, из которого надо считать данные: ";
std::cin >> inputFileName;

std::ifstream inputFile(inputFileName);

if (!inputFile.is_open()) {
    std::cerr << "Не удалось открыть файл." << std::endl;
    return 1; // Возвращаем ошибку
}

std::cout << "Данные успешно считались из файла! \n";
inputFile >> num_students;
inputFile >> outputFileName;

inputFile.close();
```

В случае, если пользователь выбрал ввести данные через консоль, у него запрашивается количество студентов и имя выходного файла. Ввод через консоль происходит следующим образом:
```cpp
std::cout << "Введите число студентов, который будут сдавать экзамен: ";
std::cin >> num_students;

std::cout << "Выведите полный путь к файлу, куда записать результат работы программы: ";
std::cin >> outputFileName;
```

### Описание остальной части программы
Сначала формируется вектор `tickets_number` с уникальными номерами билетов каждого из студентов. Засчёт цикла `while` номер билета для каждого студента генерируется до тех пор, пока не станет уникальным среди тех билетов, которые уже есть в массиве `tickets_number`.
```cpp
 for (int i = 0; i < num_students; ++i) {
    std::random_device rd;
    std::mt19937 gen(rd());
    std::uniform_int_distribution<int> dis(2, 30);

    int ticket_number = dis(gen);
    auto ind = std::find(tickets_number.begin(), tickets_number.end(), ticket_number);

    while (ind != tickets_number.end())
    {
        ticket_number = dis(gen);
        ind = std::find(tickets_number.begin(), tickets_number.end(), ticket_number);
    }

    tickets_number.push_back(ticket_number);
}
```

В основной части программы присутствует цикл, который создаёт нужное количество потоков студентов:
```cpp
for (int i = 0; i < num_students; ++i) {
    int *student_id = new int(i + 1);
    pthread_create(&students[i], nullptr, StudentThread, (void *)student_id);
}
```

После создаётся поток преподавателя:
```cpp
pthread_create(&teacher, nullptr, TeacherThread, nullptr);
```

В функции `void *StudentThread(void *arg)` входным аргументов является id текущего студента. Внутри цикла `while` сначала происходит блокировка **mutex** при помощи строки `pthread_mutex_lock(&mutex)`, чтобы заблокировать доступ к общим переменным у других потоков студентов. Сначала идёт проверка на то, отвечал ли уже текущий студент на экзамене Далее выводится информация о билете, который выпал студенту, после чего генерируются число **queue_time** и **preparation_time**, описанные выше. После того, как студент сдал преподавателю билет, при помощи `pthread_cond_signal(&teacher_cond)` вызывается поток Преподавателя. Когда преподаватель проверил работу, очередь сдачи экзамена переходит к следующему студенту. Также отмечу, что вместе с выводом информации на консоль, та же информация дублируется в выходной файл, указанный во входных данных в начале выполнения программы.
```cpp
void *StudentThread(void *arg) {
    int student_id = *((int *)arg);

    while (true) {
        pthread_mutex_lock(&mutex);

        // Проверка, ответил ли уже этот студент
        if (answered_students >= num_students) {
            pthread_mutex_unlock(&mutex);
            break;
        }

        int queue_time = rand() % 2 + 1;
        int preparation_time = rand() % 3 + 1;

        sleep(queue_time);
        // Студент выбирает билет
        std::cout << "Студент " << student_id << " выбрал билет: " << tickets_number[student_id - 1] << std::endl;
        output_file << "Студент " << student_id << " выбрал билет: " << tickets_number[student_id - 1] << std::endl;

        pthread_mutex_unlock(&mutex);

        // Очередь перед следующим студентом
        sleep(queue_time);

        // Защита билета
        pthread_mutex_lock(&mutex);
        std::cout << "Студент " << student_id << " защищает билет: " << tickets_number[student_id - 1] << std::endl;
        output_file << "Студент " << student_id << " защищает билет: " << tickets_number[student_id - 1] << std::endl;
        sleep(preparation_time);
        is_teacher_active = true;
        current_student = student_id;
        answered_students++;
        pthread_cond_signal(&teacher_cond);
        pthread_mutex_unlock(&mutex);
        sleep(preparation_time);

        // Ожидание ответа от преподавателя
        pthread_mutex_lock(&mutex);
        while (is_teacher_active) {
            pthread_cond_wait(&student_cond, &mutex);
        }
        pthread_mutex_unlock(&mutex);
        sleep(1);

        break;
    }

    pthread_exit(NULL); // Явное завершение потока
}
```

Теперь рассмотрим функцию `void *TeacherThread(void *arg)`. Для начала в цикле блокируется **mutex**, после чего идёт проверка на то, не должен ли закончиться экзамен (не ответил ли еще каждый из студентов на свой билет). Когда преподаватель получает сигнал от студента о готовности, генерируется время проверки билета - `checking_time`. После проверки билета генерируется рандомная оценка от 1 до 10, и вся информация об оценке текущего студента выводится на экран. А также, здесь, аналогично потокам студентов, вся информация, которая выводится на консоль, выводится и в выходной файл.
```cpp
void *TeacherThread(void *arg) {
    while (true) {
        pthread_mutex_lock(&mutex);

        if (answered_students >= num_students) {
            std::cout << "Все студенты сдали экзамен. Программа завершена. Результат записан в выходной файл.";
            output_file << "Все студенты сдали экзамен. ";
            pthread_mutex_unlock(&mutex);
            break;
        }

        while (!is_teacher_active) {
            pthread_cond_wait(&teacher_cond, &mutex);
        }

        int checking_time = rand() % 2 + 1;

        std::cout << "Преподаватель проверяет работу студента " << current_student << std::endl;
        output_file << "Преподаватель проверяет работу студента " << current_student << std::endl;
        sleep(checking_time);
        int grade = rand() % 10 + 1;
        std::cout << "Преподаватель выставляет оценку " << grade << " студенту " << current_student << std::endl;
        output_file << "Преподаватель выставляет оценку " << grade << " студенту " << current_student << std::endl;

        is_teacher_active = false;
        pthread_cond_signal(&student_cond);
        pthread_mutex_unlock(&mutex);
    }

    pthread_exit(NULL);
}
```

## Логи выполнения программ

